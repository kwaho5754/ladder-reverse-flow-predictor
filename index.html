<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>사다리 블럭 예측 결과</title>
  <style>
    body {
      font-family: "Noto Sans KR", sans-serif;
      background: #f4f7ff;
      padding: 2rem;
    }
    h1 {
      font-size: 1.8rem;
      text-align: center;
      margin-bottom: 2rem;
    }
    #round-info {
      font-size: 1rem;
      color: #555;
      margin-left: 0.5rem;
    }
    .summary-box {
      max-width: 1000px;
      margin: 0 auto 2rem auto;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 0 6px rgba(0,0,0,0.1);
      padding: 1rem;
    }
    .summary-box h2 {
      text-align: center;
      margin-bottom: 1rem;
    }
    .summary-row {
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      justify-content: space-around;
    }
    .summary-half {
      flex: 1;
      min-width: 480px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 0.6rem;
      border-bottom: 1px solid #ddd;
      text-align: left;
      font-size: 0.95rem;
    }
    th {
      background: #eef2ff;
    }
  </style>
</head>
<body>
  <h1>
    🔮 사다리 블럭 예측 결과
    <span id="round-info">(예측 회차: 불러오는 중...)</span>
  </h1>

  <div id="results"></div>

  <script>
    async function loadLatestRound() {
      try {
        const res = await fetch('/latest_round');
        const data = await res.json();
        document.getElementById("round-info").textContent = `(예측 회차: ${data.round}회)`;
      } catch (e) {
        console.error("예측 회차 불러오기 실패", e);
      }
    }

    async function loadResults() {
      const resultContainer = document.getElementById("results");
      resultContainer.innerHTML = "";

      const modes = [
        "3block_orig", "3block_flip_full", "3block_flip_start", "3block_flip_odd_even",
        "4block_orig", "4block_flip_full", "4block_flip_start", "4block_flip_odd_even"
      ];

      const limits = [1, 2, 3, 4, 5, 6];
      const topTrack = {}, bottomTrack = {}, topRounds = {}, bottomRounds = {};
      const fetchPromises = [];

      const transformLabel = {
        "orig": "원본",
        "flip_full": "대칭",
        "flip_start": "시작점",
        "flip_odd_even": "홀짝"
      };

      for (const limit of limits) {
        for (const mode of modes) {
          fetchPromises.push(
            fetch(`/predict?mode=${mode}&limit=${limit}`)
              .then(res => res.json())
              .then(data => {
                const blockType = mode.startsWith("3block") ? "3BL" : "4BL";
                const transformKey = Object.keys(transformLabel).find(k => mode.includes(k));
                const transformName = transformLabel[transformKey] || "원본";

                const topItem = data["상단값들"][limit - 1];
                const bottomItem = data["하단값들"][limit - 1];

                if (topItem?.값) {
                  if (!topTrack[topItem.값]) topTrack[topItem.값] = [];
                  topTrack[topItem.값].push({ 순번: topItem.순번, 블럭: blockType, 방식: transformName });
                  topRounds[topItem.값] = (topRounds[topItem.값] || 0) + 1;
                }

                if (bottomItem?.값) {
                  if (!bottomTrack[bottomItem.값]) bottomTrack[bottomItem.값] = [];
                  bottomTrack[bottomItem.값].push({ 순번: bottomItem.순번, 블럭: blockType, 방식: transformName });
                  bottomRounds[bottomItem.값] = (bottomRounds[bottomItem.값] || 0) + 1;
                }
              })
              .catch(e => console.error("예측 실패", mode, limit, e))
          );
        }
      }

      await Promise.all(fetchPromises);

      const container = document.createElement("div");
      container.className = "summary-box";

      const row = document.createElement("div");
      row.className = "summary-row";

      const topBox = document.createElement("div");
      topBox.className = "summary-half";
      topBox.innerHTML = `<h2>📊 예측 전체 상단값 순번 추적</h2>${renderTable(topTrack, topRounds)}`;

      const bottomBox = document.createElement("div");
      bottomBox.className = "summary-half";
      bottomBox.innerHTML = `<h2>📊 예측 전체 하단값 순번 추적</h2>${renderTable(bottomTrack, bottomRounds)}`;

      row.appendChild(topBox);
      row.appendChild(bottomBox);
      container.appendChild(row);
      resultContainer.appendChild(container);
    }

    function renderTable(trackMap, countMap) {
      return `
        <table>
          <thead><tr><th>값</th><th>출현횟수</th><th>순번 상세</th></tr></thead>
          <tbody>
            ${Object.entries(trackMap).map(([val, arr]) => {
              const 순번들 = arr.map(obj =>
                `순번 ${obj.순번} (${obj.블럭}, ${obj.방식})`
              ).join("<br>");
              return `<tr><td>${val}</td><td>${countMap[val]}</td><td>${순번들}</td></tr>`;
            }).join("")}
          </tbody>
        </table>
      `;
    }

    loadLatestRound();
    loadResults();
  </script>
</body>
</html>
